/**
 * MIT License
 *
 * Copyright (c) 2025 TimeKill
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * Tests for Humanizer Utility
 * Tests the AI detection and text humanization functionality from core/lib/humanizer.ts
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mockRedisClient } from '../helpers/mocks';
import { humanizeText } from '../../packages/core/lib/humanizer';

// Mock dependencies
vi.mock('@upstash/redis', () => ({
  Redis: vi.fn(() => mockRedisClient()),
}));

vi.mock('../../packages/core/lib/prisma', () => ({
  prisma: {
    subscription: {
      findUnique: vi.fn(),
    },
    humanizerRun: {
      create: vi.fn(),
    },
  },
}));

// Mock fetch for API calls
global.fetch = vi.fn();

describe('Humanizer Utility', () => {
  const aiText = 'This is text generated by an AI that sounds very artificial and formulaic.';
  const humanizedText = 'This sounds more like something a human would write, with natural flow and varied structure.';
  
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Mock Sapling API response - initial detection
    (global.fetch as any).mockImplementation((url) => {
      if (url.includes('sapling.ai')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({
            score: url.includes(encodeURIComponent(humanizedText)) ? 0.15 : 0.85, // Lower score for humanized text
            text: url.includes(encodeURIComponent(humanizedText)) ? humanizedText : aiText,
          }),
        });
      }
      
      // Mock Gemini rewriting API
      if (url.includes('generativelanguage.googleapis.com')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({
            candidates: [
              {
                content: {
                  parts: [
                    {
                      text: `
[
  "${humanizedText}",
  "Another rewritten version that's also more human-like and natural.",
  "A third version that sounds casual and authentic."
]
                      `,
                    },
                  ],
                },
              },
            ],
          }),
        });
      }
      
      return Promise.reject(new Error('Unexpected URL in fetch'));
    });
  });

  it('should humanize AI-generated text successfully', async () => {
    // Mock the Redis get to return null (no cache)
    const mockRedis = mockRedisClient();
    mockRedis.get.mockResolvedValue(null);
    mockRedis.incr.mockResolvedValue(1); // First request for rate limit
    
    // Mock empty subscription (free tier)
    const mockSubscription = null;
    const mockPrisma = {
      subscription: {
        findUnique: vi.fn().mockResolvedValue(mockSubscription),
      },
      humanizerRun: {
        create: vi.fn().mockResolvedValue({}),
      },
    };
    vi.mock('../../packages/core/lib/prisma', () => ({
      prisma: mockPrisma,
    }));
    
    // Call the function
    const result = await humanizeText(aiText, 'user_123');
    
    // Check the result
    expect(result).toEqual({
      humanizedText,
      saplingScore: 0.15,
      iterations: 1,
      similarity: expect.any(Number),
    });
    
    // Verify APIs were called
    expect(global.fetch).toHaveBeenCalledTimes(3); // Initial check + gemini + final check
    
    // Verify cache was checked and set
    expect(mockRedis.get).toHaveBeenCalled();
    expect(mockRedis.set).toHaveBeenCalled();
    
    // Verify rate limit was checked
    expect(mockRedis.incr).toHaveBeenCalled();
    expect(mockRedis.expire).toHaveBeenCalled();
    
    // Verify run was logged
    expect(mockPrisma.humanizerRun.create).toHaveBeenCalled();
  });
  
  it('should return cached result if available', async () => {
    // Mock the Redis get to return cached data
    const mockRedis = mockRedisClient();
    const cachedResult = {
      humanizedText,
      saplingScore: 0.15,
      iterations: 1,
      similarity: 0.95,
    };
    mockRedis.get.mockResolvedValue(JSON.stringify(cachedResult));
    
    // Call the function
    const result = await humanizeText(aiText, 'user_123');
    
    // Check the result
    expect(result).toEqual(cachedResult);
    
    // Verify APIs were NOT called
    expect(global.fetch).not.toHaveBeenCalled();
    
    // Verify cache was checked
    expect(mockRedis.get).toHaveBeenCalled();
    
    // Verify rate limit was NOT checked
    expect(mockRedis.incr).not.toHaveBeenCalled();
  });
  
  it('should return original text if already human-like', async () => {
    // Mock the Redis get to return null (no cache)
    const mockRedis = mockRedisClient();
    mockRedis.get.mockResolvedValue(null);
    mockRedis.incr.mockResolvedValue(1);
    
    // Mock Sapling API to return low score (already human-like)
    (global.fetch as any).mockImplementation((url) => {
      if (url.includes('sapling.ai')) {
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({
            score: 0.15, // Already human-like
            text: humanizedText,
          }),
        });
      }
      return Promise.reject(new Error('Unexpected URL in fetch'));
    });
    
    // Call the function
    const result = await humanizeText(humanizedText, 'user_123');
    
    // Check the result
    expect(result).toEqual({
      humanizedText,
      saplingScore: 0.15,
      iterations: 0,
      similarity: 1.0,
    });
    
    // Verify only Sapling API was called once
    expect(global.fetch).toHaveBeenCalledTimes(1);
    
    // Verify cache was checked and set
    expect(mockRedis.get).toHaveBeenCalled();
    expect(mockRedis.set).toHaveBeenCalled();
  });
  
  it('should throw an error when rate limit is exceeded for free tier', async () => {
    // Mock the Redis get to return null (no cache)
    const mockRedis = mockRedisClient();
    mockRedis.get.mockResolvedValue(null);
    mockRedis.incr.mockResolvedValue(11); // Over free tier limit of 10
    
    // Mock empty subscription (free tier)
    const mockPrisma = {
      subscription: {
        findUnique: vi.fn().mockResolvedValue(null),
      },
    };
    vi.mock('../../packages/core/lib/prisma', () => ({
      prisma: mockPrisma,
    }));
    
    // Call the function and expect it to throw
    await expect(
      humanizeText(aiText, 'user_123')
    ).rejects.toThrow('Rate limit exceeded');
    
    // Verify APIs were NOT called
    expect(global.fetch).not.toHaveBeenCalled();
    
    // Verify subscription was checked
    expect(mockPrisma.subscription.findUnique).toHaveBeenCalled();
  });
  
  it('should allow unlimited usage for pro subscribers', async () => {
    // Mock the Redis get to return null (no cache)
    const mockRedis = mockRedisClient();
    mockRedis.get.mockResolvedValue(null);
    mockRedis.incr.mockResolvedValue(100); // Way over free tier limit
    
    // Mock pro subscription
    const mockSubscription = {
      status: 'active',
      plan: 'pro',
    };
    const mockPrisma = {
      subscription: {
        findUnique: vi.fn().mockResolvedValue(mockSubscription),
      },
      humanizerRun: {
        create: vi.fn().mockResolvedValue({}),
      },
    };
    vi.mock('../../packages/core/lib/prisma', () => ({
      prisma: mockPrisma,
    }));
    
    // Call the function - should not throw
    const result = await humanizeText(aiText, 'user_123');
    
    // Check the result
    expect(result).toEqual({
      humanizedText,
      saplingScore: 0.15,
      iterations: 1,
      similarity: expect.any(Number),
    });
    
    // Verify subscription was checked
    expect(mockPrisma.subscription.findUnique).toHaveBeenCalled();
  });
});